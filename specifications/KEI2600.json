{
  "name": "KEI2600",
  "devicetype": "SMU",
  "superclass": "KeithleyDevice",
  "imports": "import requests\nfrom py_instrument_control_lib.device_base.DeviceException import DeviceException\nimport time\nimport copy\nfrom typing import Optional",
  "commands": [
    {
      "name": "execute",
      "type": "code",
      "signature": "command: str",
      "code": "if self._buffering_enabled:\n    self._buffered_script.append(command)\nelse:\n    super().execute(command)"
    },
    {
      "name": "query",
      "type": "code",
      "signature": "query: str",
      "return": "Optional[str]",
      "code": "if self._buffering_enabled:\n    buffer_name = 'A_M_BUFFER' if query.startswith('smua') else 'B_M_BUFFER'\n    query = query[:-1] + buffer_name + ')'\n    self._buffered_script.append(query)\n    return \"inf\"\nelse:\n    command = 'reading = ' + query\n    self.execute(command)\n    self.execute('print(reading)')\n    response = self._socket.recv(1024)\n    response_decoded = response.decode()\n    if 'TSP>' in response_decoded:\n        raise DeviceException(msg='Do not use the web interface before or during use of this control lib! '\n                                  'You have to restart your device in order to continue.')\n    return response_decoded"
    },
    {
      "name": "measure",
      "docs": "This function measures a certain unit on a specific channel. Can be used to measure voltage, current, power or resistance.\n:param unit: The thing to measure.\n:param channel: The channel to measure on.\n:param check_errors: Whether to check the error buffer after the execution.\n:return: None.",
      "type": "generated",
      "signature": "unit: Unit, channel: SMUChannel",
      "return": "float",
      "command": "f'{channel.value}.measure.{unit.value}()'"
    },
    {
      "name": "toggle_channel",
      "type": "generated",
      "signature": "channel: SMUChannel, enable: bool",
      "command": "f'{channel.value}.source.output = {channel.value}.OUTPUT_{(\"ON\" if enable else \"OFF\")}'"
    },
    {
      "name": "set_level",
      "type": "generated",
      "signature": "unit: Unit, channel: SMUChannel, level: float",
      "requirements": "unit in (Unit.VOLTAGE, Unit.CURRENT)",
      "command": "f'{channel.value}.source.level{unit.value} = {level}'"
    },
    {
      "name": "set_limit",
      "type": "generated",
      "signature": "unit: Unit, channel: SMUChannel, limit: float",
      "requirements": "unit in (Unit.VOLTAGE, Unit.CURRENT, Unit.POWER)",
      "command": "f'{channel.value}.source.limit{unit.value} = {str(limit)}'"
    },
    {
      "name": "toggle_autorange",
      "type": "generated",
      "signature": "unit: Unit, channel: SMUChannel, mode: SMUMode, enable: bool",
      "requirements": "unit in (Unit.VOLTAGE, Unit.CURRENT)",
      "command": "f'{channel.value}.{mode.value}.autorange{unit.value} = {int(enable) if mode == SMUMode.MEASURE else channel.value + \".AUTORANGE_\" + (\"ON\" if enable else \"OFF\")}'"
    },
    {
      "name": "toggle_measure_analog_filter",
      "type": "generated",
      "signature": "channel: SMUChannel, enable: bool",
      "command": "f'{channel.value}.measure.analogfilter = {int(enable)}'"
    },
    {
      "name": "set_range",
      "type": "generated",
      "signature": "unit: Unit, channel: SMUChannel, mode: SMUMode, range_: float",
      "requirements": "unit in (Unit.VOLTAGE, Unit.CURRENT)",
      "command": "f'{channel.value}.{mode.value}.range{unit.value} = {range_}'"
    },
    {
      "name": "set_sense_mode",
      "type": "generated",
      "signature": "channel: SMUChannel, sense_arg: SMUSense",
      "command": "f'{channel.value}.sense = {channel.value}.{sense_arg.value}'"
    },
    {
      "name": "set_measure_plc",
      "type": "generated",
      "signature": "channel: SMUChannel, value: float",
      "requirements": "0.001 < value < 25",
      "command":  "f'{channel.value}.measure.nplc = {value}'"
    },
    {
      "name": "set_measure_low_range",
      "type": "generated",
      "signature": "unit: Unit, channel: SMUChannel, value: float",
      "requirements": "unit in (Unit.VOLTAGE, Unit.CURRENT)",
      "command":  "f'{channel.value}.measure.lowrange{unit.value} = {value}'"
    },
    {
      "name": "set_measure_auto_zero",
      "type": "generated",
      "signature": "channel: SMUChannel, auto_zero: Autozero",
      "command":  "f'{channel.value}.measure.autozero = {channel.value}.{auto_zero.value}'"
    },
    {
      "name": "set_measure_count",
      "type": "generated",
      "signature": "channel: SMUChannel, nr_of_measurements: int",
      "command":  "f'{channel.value}.measure.count = {nr_of_measurements}'"
    },
    {
      "name": "set_source_function",
      "type": "generated",
      "signature": "channel: SMUChannel, src_func: SourceFunction",
      "command":  "f'{channel.value}.source.func = {channel.value}.{src_func.value}'"
    },
    {
      "name": "set_source_off_mode",
      "type": "generated",
      "signature": "channel: SMUChannel, src_off_mode: SourceOffMode",
      "command":  "f'{channel.value}.source.offmode = {channel.value}.{src_off_mode.value}'"
    },
    {
      "name": "set_source_settling",
      "type": "generated",
      "signature": "channel: SMUChannel, src_settling: SourceSettling",
      "command":  "f'{channel.value}.source.settling = {channel.value}.{src_settling.value}'"
    },
    {
      "name": "toggle_source_sink",
      "type": "generated",
      "signature": "channel: SMUChannel, enable: bool",
      "command":  "f'{channel.value}.source.sink = {str(int(enable))}'"
    },
    {
      "name": "display_measure_function",
      "type": "generated",
      "signature": "channel: SMUChannel, diplay_measure_func: SMUDisplay",
      "command":  "f'display.{channel.value}.measure.func = display.{diplay_measure_func.value}'"
    },
    {
      "name": "toggle_beep",
      "type": "generated",
      "signature": "enable: bool",
      "command": "f'beeper.enable = beeper.{\"ON\" if enable else \"OFF\"}'"
    },
    {
      "name": "beep",
      "type": "generated",
      "docs": "Send a beeping sound with a specific duration and frequency to the SMU.\n:param duration: Time in seconds to play the beeping sound.\n:param frequency: Frequency in HZ of the sound to play.\n:param check_errors: Whether to check the error buffer after the execution.\n:return: None.",
      "signature": "duration: float, frequency: int",
      "command": "f'beeper.beep({duration}, {frequency})'"
    },
    {
      "name": "toggle_buffering",
      "type": "code",
      "signature": "enable: bool",
      "code": "self._buffering_enabled = enable\nif not hasattr(self, '_buffered_script'):\n    self._buffered_script = []"
    },
    {
      "name": "execute_buffered_script",
      "type": "code",
      "signature": "blocking: bool = True",
      "code": "self.toggle_buffering(False)\n\nbuffer_entries_a = len([line for line in self._buffered_script if 'A_M_BUFFER' in line])\nbuffer_entries_b = len([line for line in self._buffered_script if 'B_M_BUFFER' in line])\ndefault_script = [\"loadscript pyBuff\",\n                  f'A_M_BUFFER = smua.makebuffer({buffer_entries_a})',\n                  f'B_M_BUFFER = smub.makebuffer({buffer_entries_b})',\n                  'A_M_BUFFER.appendmode = 1',\n                  'B_M_BUFFER.appendmode = 1']\nself._buffered_script = default_script + self._buffered_script\nself._buffered_script.append('endscript')\n\nexit_payload: dict = {'command': 'keyInput', 'value': 'K'}\npayloads: list[dict] = []\n\nn = 32\nchunks = [self._buffered_script[i:i + n] for i in range(0, len(self._buffered_script), n)]\n\npayloads += [self.__make_payload('\\n'.join(chunk)) for chunk in chunks]\npayloads += [self.__make_payload('pyBuff.save()'), exit_payload]\n\nfor payload in payloads:\n    response = requests.post('http://' + self._config.ip + '/HttpCommand', json=payload)\n    if response.status_code != 200:\n        raise DeviceException(msg='Failed to send and execute buffered script')\n    time.sleep(0.5)\n\nself.execute('pyBuff()')\n\nprint('Waiting for script to complete')\nif blocking:\n    status = requests.post('http://' + self._config.ip + '/HttpCommand', json={\n        \"command\": \"shellOutput\",\n        \"timeout\": 3,\n        \"acceptsMultiple\": True\n    })\n    while status.json()['status']['value'] == 'timeout':\n        status = requests.post('http://' + self._config.ip + '/HttpCommand', json={\n            \"command\": \"shellOutput\",\n            \"timeout\": 3,\n            \"acceptsMultiple\": True\n        })\n    print('Script finished')"
    },
    {
      "name": "__make_payload",
      "type": "code",
      "return": "dict",
      "signature": "value: str",
      "code": "return {'command': 'shellInput', 'value': value}"
    },
    {
      "name": "read_buffer",
      "type": "code",
      "signature": "",
      "code": "buffer_a = self.__read_channel_buffer(SMUChannel.CHANNEL_A)\nbuffer_b = self.__read_channel_buffer(SMUChannel.CHANNEL_B)\nself._buffer = (buffer_a, buffer_b)"
    },
    {
      "name": "__read_channel_buffer",
      "type": "code",
      "signature": "channel: SMUChannel",
      "return": "list[str]",
      "code": "buffer_name = ('A' if channel == SMUChannel.CHANNEL_A else 'B') + '_M_BUFFER'\nbuffer_size = len([line for line in self._buffered_script if buffer_name in line]) - 2\nbatch_size = 1024 // 15\n\nbuffer = []\noffset = 1\nwhile offset + batch_size <= buffer_size:\n    buffer += self.__get_buffer_content(offset, batch_size, buffer_name)\n    offset += batch_size\n\nif (remaining := buffer_size % batch_size) > 0:\n    buffer += self.__get_buffer_content(offset, remaining, buffer_name)\n\nreturn buffer"
    },
    {
      "name": "get_buffer",
      "type": "code",
      "signature": "",
      "return": "tuple[list[str], list[str]]",
      "code": "return copy.deepcopy(self._buffer)"
    },
    {
      "name": "__get_buffer_content",
      "type": "code",
      "signature": "offset: int, batch_size: int, buffer_name: str",
      "return": "list[str]",
      "code": "print_query = f'printbuffer({offset}, {offset + batch_size - 1}, {buffer_name})'\nself.execute(print_query)\nreturn self._socket.recv(1024).decode().replace('\\n', '').split(', ')"
    },
    {
      "name": "next_buffer_element",
      "type": "code",
      "signature": "channel: SMUChannel",
      "return": "float",
      "code": "if len(self._buffer) == 0:\n    raise Exception('Buffer is empty!')\nbuffer_idx = 0 if channel == SMUChannel.CHANNEL_A else 1\nreturn float(self._buffer[buffer_idx].pop(0))"
    }
  ]
}
